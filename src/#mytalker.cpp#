#include "ros/ros.h"
#include "std_msgs/String.h"
#include "std_msgs/Float64.h"

#include <sstream>

/**
 * This tutorial demonstrates simple sending of messages over the ROS system.
 */
int main(int argc, char **argv)
{
  /**
   * The ros::init() function needs to see argc and argv so that it can perform
   * any ROS arguments and name remapping that were provided at the command line.
   * For programmatic remappings you can use a different version of init() which takes
   * remappings directly, but for most command-line programs, passing argc and argv is
   * the easiest way to do it.  The third argument to init() is the name of the node.
   *
   * You must call one of the versions of ros::init() before using any other
   * part of the ROS system.
   */
  ros::init(argc, argv, "talker");

  /**
   * NodeHandle is the main access point to communications with the ROS system.
   * The first NodeHandle constructed will fully initialize this node, and the last
   * NodeHandle destructed will close down the node.
   */
  ros::NodeHandle n;

  /**
   * The advertise() function is how you tell ROS that you want to
   * publish on a given topic name. This invokes a call to the ROS
   * master node, which keeps a registry of who is publishing and who
   * is subscribing. After this advertise() call is made, the master
   * node will notify anyone who is trying to subscribe to this topic name,
   * and they will in turn negotiate a peer-to-peer connection with this
   * node.  advertise() returns a Publisher object which allows you to
   * publish messages on that topic through a call to publish().  Once
   * all copies of the returned Publisher object are destroyed, the topic
   * will be automatically unadvertised.
   *
   * The second parameter to advertise() is the size of the message queue
   * used for publishing messages.  If messages are published more quickly
   * than we can send them, the number here specifies how many messages to
   * buffer up before throwing some away.
   */
  ros::Publisher chatter1_pub = n.advertise<std_msgs::String>("chatter_str", 1000);
  ros::Publisher chatter2_pub = n.advertise<std_msgs::Float64>("chatter_flt", 1000);

  ros::Rate loop_rate(10);

  /**
   * A count of how many messages we have sent. This is used to create
   * a unique string for each message.
   */
  int count = 0;
  while (ros::ok())
  {
    /**
     * This is a message object. You stuff it with data, and then publish it.
     */
    std_msgs::String msg;
    std_msgs::Float64 num;

    std::stringstream ss;
    ss << "hello world " << count;
    msg.data = ss.str();

    num.data = (double)count / 4.0;


    ROS_INFO("%s", msg.data.c_str());

    if(count%8==0) {
      chatter2_pub.publish(num);
    }

    /**
     * The publish() function is how you send messages. The parameter
     * is the message object. The type of this object must agree with the type
     * given as a template parameter to the advertise<>() call, as was done
     * in the constructor above.
     */
    chatter1_pub.publish(msg);

    ros::spinOnce();

    loop_rate.sleep();
    ++count;
  }


  return 0;
}




  /* This is a visualization of what the x and y coordinates represent on 
   relative to the direction that the turtlebot is facing.
|         X+        . (destination)
|        |
|        |
|      (forward)
|        __
|      /   \
|      |___|    
|        ____________ Y+
  */
void RoboState::turnForward()
{
 
   // gives the angle between y axis and hypotenuse
    double angleRotation = atan(getX()/getY());
    // uses pythagorean theorem to figure out distance 
    double finalX = sqrt(pow(getX(),2) + pow(getY(),2));

    ROS_INFO("The angle of rotation is %f", angleRotation);

    this->velocityCommand.linear.x = 0.0;
    // positive angle of rotation, so we just rotate angleRotation/90 times the amount we would need to rotate 90 degrees left
    if(angleRotation > 0)
      this->velocityCommand.angular.z = left_90*(angleRotation/90);
    else // negative angle of rotation, so we just rotate angleRotation/90 times the amount we would need to rotate 90 degrees right
      this->velocityCommand.angular.z = right_90*(-1*angleRotation/90);
    velocityPublisher.publish(this->velocityCommand);
    // x is aligned with the hypotenuse, so we set it equal to the length of the hypotenuse
    setX(finalX);
    setY(0);

    // we adjusted the values, so we no longer need to turn
    setTurnAndGoForward(false);
    
    
  }
  
  void RoboState::bumperCallback(const create_node::TurtlebotSensorState::ConstPtr& msg)
  {
    // if bumpers don't complain, don't run the loop
    if(msg->bumps_wheeldrops != 0){
    ROS_INFO("You hit an object! Motion terminating.");
    ROS_INFO("The remaining x was:%f and the remaining y was: %f.", getX(), getY());
    setX(0);
    setY(0);
    // allow RoboState to receive messages again
    setMessageStatus(false);
    }
  }
  
  // Basic initialization and publisher/subscribers. May need to adjust rates.
  RoboState::RoboState(ros::NodeHandle rosNode): xCoord(0), yCoord(0), messageStatus(false), turnAndGoForward(false)
  {
    this->node = rosNode;
    this->velocityPublisher = this->node.advertise<geometry_msgs::Twist>("/mobile_base/commands/velocity", 1);
    this->messageSubscriber=node.subscribe("example",1, &RoboState::messageCallback, this);
    this->bumperSubscriber = this->node.subscribe("/mobile_base/sensors/core", 100, &RoboState::bumperCallback, this);
  }

  // basically goForward does everything for us until it tells us we're done
  void RoboState::goRobotGo()
  {
    if(isMessageSet()){
      goForward();
    }
  }
  
  // first we turn the robot towards destination, then just go forward like normal
  void RoboState::turnThenForwardGo(){
    if(isMessageSet()){
      if(getTurnAndGoForward())
	turnForward();
      else
	goForward();
    }

  }

  bool RoboState::getTurnAndGoForward()
  {
    return turnAndGoForward;
  }
  
  double RoboState::xIsNegative()
  {

    if( getX() > 0)
      return 1;
    else
      return -1;
  }

  void RoboState::goForward()
  {
    // may need to adjust value for whatever reason

    usleep(100000);

    
    if(getX()!=0)
      {

	double xMoveCommand; 
	// only move forward incrementAmt if the amount left to move is greater than incrementAmt
	if (std::abs(getX()) > incrementAmt){
	  // ideally, this should result in forward (or backward movement)
	  // in the x direction by incrementAmt
	  xMoveCommand = incrementAmt*movementMultiple*xIsNegative();
	  this->velocityCommand.linear.x = incrementAmt*movementMultiple;
	  this->velocityCommand.angular.z = 0.0;
	  
	  velocityPublisher.publish(this->velocityCommand);
	  // ideally, this is the amount that x has changed
	  this->incrementX(-1*xIsNegative()*incrementAmt);
	  // we should wait until forward movement has finished before we go on
	  usleep(movementInterval);

	  ROS_INFO("We moved %f", incrementAmt);
	  ROS_INFO("The remaining amount to move is %f", getX());
	}
	else{
	  // we have less than the incrementAmt left, so we move however much remaining
	  // do not need to know if xCoord is negative or not, since we get the actual value
	  xMoveCommand = getX()*movementMultiple;
	  this->velocityCommand.linear.x = xMoveCommand;
	  this->velocityCommand.angular.z = 0.0;

	  velocityPublisher.publish(this->velocityCommand);
	  ROS_INFO("We moved forward %f", getX());
	  // assume we moved forward or backward in the exactly how much was left in xCoord
	  this->incrementX(-getX());

	  ROS_INFO("The remaining amount to move is %f (should be zero)", getX());
	}
      }
    else{
      if(getY()==0){
	// means that both x and y are 0, so we should stop 
	// does this by setting messageStatus to false
	ROS_INFO("The both x and y are zero, so we are done with movement.");
	ROS_INFO("Feel free to send more messages.");
	setMessageStatus(false);
      }
      else{
	// if x is zero, but y isnt, then we need to rotate to face towards the final destination
	rotateLR();
	ROS_INFO("The value of x was zero, so we did not move forward.");
      }
    }
  }
	      

  // this is called whenever we receive a message 
  void RoboState::messageCallback(const node_example::NodeExampleData::ConstPtr &msg)
  {

    if(!isMessageSet())
      {
	ROS_INFO("X and Y coordinates sent were: x:%f y:%f", msg->a, msg->b);
	setX(msg->a);
	setY(msg->b);
	ROS_INFO("xCoord is: %f. yCoord is: %f", getX(), getY());
	setMessageStatus(true);
	//setTurnAndGoForward(true);
      }
    else
      ROS_INFO("Cannot accept message. Movement still in progress.");
  }

  // assumes that x is zero and y is nonzero. May want to add cases for when method is called in error
  void RoboState::rotateLR()
  {
    ROS_INFO("Switching x and y coordinates.");
    usleep(500000);
    if( getY() > 0) // means that destination is on right
      rotateLeft();
    else if ( getY() < 0) // means that destination is on right
      rotateRight();
    else 
      setMessageStatus(false); // means that x and y was zero
    if(getY() > 0){
      setX(getY());
      ROS_INFO("Your y-coordinate was positive.");
    }
    else if(getY() < 0){
      setX(-getY());
      ROS_INFO("Your y-coordinate was negative.");
    }
      else{
	ROS_INFO("Your y-coordinate was zero.");
      }
      setY(0);
    ROS_INFO("x and y coordinates swapped.");
  }
  
  void RoboState::rotateLeft()
  {
    ROS_INFO("Rotating left.");
    usleep(500000);
    this->velocityCommand.linear.x = 0.0;
    this->velocityCommand.angular.z = left_90;
	
    velocityPublisher.publish(this->velocityCommand);
  }

  void RoboState::rotateRight()
  {
    ROS_INFO("Rotating right.");
    usleep(500000);
    this->velocityCommand.linear.x = 0.0;
    this->velocityCommand.angular.z = right_90;
    velocityPublisher.publish(this->velocityCommand);
  }


  void RoboState::setMessageStatus(bool status)
  {
    messageStatus=status;
  }

  bool RoboState::isMessageSet()
  {
    return messageStatus;
  }
  
  void RoboState::incrementX(double x)
  {
    xCoord += x;
  }

  void RoboState::incrementY(double y)
  {
    yCoord += y;
  }
  
  double RoboState::getX()
  {
    return xCoord;
  }

  void RoboState::setX(double x)
  {
    xCoord=x;
  }

  void RoboState::setY(double y)
  {
    yCoord=y;
  }

  double RoboState::getY()
  {
    return yCoord;
  }


  
  void RoboState::setTurnAndGoForward(bool value)
  {
    turnAndGoForward = value;
  }















